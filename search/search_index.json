{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"B4: Better Btrfs Backups","text":"<p>B4 is a backup tool that creates and maintains backups of your data on a Btrfs filesystem. It creates snapshots of subvolumes and sends them to a remote machine. It handles rotation schedules and cleanup of old backups and is designed to be flexible and can be used in scripts.</p> <ul> <li> <p> Setup and install</p> <p>Setup prerequisites and install B4 on your system</p> <p> Install</p> </li> <li> <p> CLI Reference</p> <p>Learn how to use B4 from the command line</p> <p> CLI Reference</p> </li> <li> <p> Examples and use cases</p> <p>Learn how to use B4 with examples and use cases</p> <p> Examples</p> </li> <li> <p> Terminology</p> <p>Learn the terminology used in B4, for a better understanding of the examples and reference</p> <p> Terminology</p> </li> </ul>"},{"location":"configuration.html","title":"Configuration","text":"<p>B4 Backup got a configuration YAML file, where you can override specific parameters as you like. The default configuration path is <code>~/.config/b4_backup.yml</code>.</p> <p>A full reference of all possible settings and their default values can be found in the code reference.</p> Example configuration based on default values<pre><code>backup_targets:\n  _default:\n    destination: null\n    dst_retention:\n      _default:\n        all: forever\n      auto:\n        1day: 1month\n        1month: infinity\n        1week: 1year\n    if_dst_dir_not_found: CREATE\n    replaced_target_ttl: 24hours\n    restore_strategy: SAFE\n    source: null\n    src_retention:\n      _default:\n        all: '1'\n      auto:\n        all: 7days\n    src_snapshot_dir: &amp;id001 .b4_backup\n    subvolume_rules:\n      /:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      _default:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      rootfs/var/lib/docker/btrfs/subvolumes:\n        backup_strategy: IGNORE\n        fallback_strategy: DROP\n  local/data:\n    destination: null\n    dst_retention: {}\n    if_dst_dir_not_found: CREATE\n    replaced_target_ttl: 24hours\n    restore_strategy: SAFE\n    source: /opt/data\n    src_retention: {}\n    src_snapshot_dir: *id001\n    subvolume_rules:\n      /:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      _default:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      rootfs/var/lib/docker/btrfs/subvolumes:\n        backup_strategy: IGNORE\n        fallback_strategy: DROP\n  localhost/test:\n    destination: null\n    dst_retention: {}\n    if_dst_dir_not_found: CREATE\n    replaced_target_ttl: 24hours\n    restore_strategy: SAFE\n    source: ssh://root@localhost/opt/test\n    src_retention: {}\n    src_snapshot_dir: *id001\n    subvolume_rules:\n      /:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      _default:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      rootfs/var/lib/docker/btrfs/subvolumes:\n        backup_strategy: IGNORE\n        fallback_strategy: DROP\n  main.example.com/b:\n    destination: null\n    dst_retention: {}\n    if_dst_dir_not_found: CREATE\n    replaced_target_ttl: 24hours\n    restore_strategy: SAFE\n    source: ssh://root@main.example.com:990/b\n    src_retention: {}\n    src_snapshot_dir: *id001\n    subvolume_rules:\n      /:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      _default:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      rootfs/var/lib/docker/btrfs/subvolumes:\n        backup_strategy: IGNORE\n        fallback_strategy: DROP\n  main.example.com/home:\n    destination: null\n    dst_retention:\n      auto:\n        all: 3days\n    if_dst_dir_not_found: CREATE\n    replaced_target_ttl: 24hours\n    restore_strategy: SAFE\n    source: ssh://root@main.example.com/home\n    src_retention: {}\n    src_snapshot_dir: *id001\n    subvolume_rules:\n      /:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      _default:\n        backup_strategy: FULL\n        fallback_strategy: DROP\n      rootfs/var/lib/docker/btrfs/subvolumes:\n        backup_strategy: IGNORE\n        fallback_strategy: DROP\nconfig_path: ~/.config/b4_backup.yml\ndefault_targets: []\nlogging:\n  loggers:\n    root:\n      level: INFO\ntimezone: utc\n</code></pre> <p>Tip</p> <p>B4 Backup is using OmegaConf to parse config files. OmegaConf also supports variables and resolvers. With resolvers it is possible to insert for example environment variables. A list of all built-in resolvers can be found here. B4 Backup implements some resolvers too. You can find them here.</p>"},{"location":"contribute.html","title":"Contribute","text":"<p>Contributions are welcome. If the code quality and tests are sufficient and the PR brings value for the project, I'm ready to accept them.</p>"},{"location":"contribute.html#keep-the-code-clean","title":"Keep the code clean","text":"<p>As we all want to keep the quality of this code high, you should aim for the following:</p> <ul> <li>Write good tests! Make sure every line of the application code is sufficiently tested.</li> <li>Clean code.</li> <li>No pipeline errors</li> </ul>"},{"location":"contribute.html#run-tests","title":"Run tests","text":"<p>If you want to verify your code didn't break anything and test it, you can simply run the unit tests locally.</p> <p>All tests are located under <code>/tests</code>.</p>"},{"location":"contribute.html#run-all-tests","title":"Run all tests","text":"<pre><code>pytest\n</code></pre>"},{"location":"contribute.html#extend-the-documentation","title":"Extend the documentation","text":"<p>The documentation is created using mkdocs and is deployed automatically, if you commit or merge in the master branch. You can find the documentation at <code>/docs</code>.</p>"},{"location":"contribute.html#start-the-development-server","title":"Start the development server","text":"<p>You can start and serve the documentation locally, which provides fancy features like hot-reload. This way you can directly see what you are typing, without the need to push it first.</p> <p>Tip</p> <p>The Code reference pages are generated dynamically by the pipeline.</p> <p>To generate these pages yourself run this script:</p> <pre><code>poetry run python docs/gen_reference_code.py\npoetry run python docs/gen_reference_config.py\npoetry run typer b4_backup/__main__.py utils docs --name b4 --title \"CLI reference\" --output docs/reference/cli.md\n</code></pre> <p>Run the development server like this:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"examples.html","title":"Examples","text":"<p>Here we collect a list of examples. These examples are part of a scenario or use-case how B4 Backup could be used to create and restore your backups.</p>"},{"location":"examples.html#pull-backup","title":"Pull backup","text":""},{"location":"examples.html#overview","title":"Overview","text":"<p>We got three servers with different target locations to backup. B4 is installed on <code>backup.example.com</code> and is pulling the backups via SSH every day using a cronjob.</p> <pre><code>flowchart TD\n    server1[\"`__nextcloud.example.com__\n      Target: /opt/nextcloud`\"] --&gt; |pull| dst[\"`__backup.example.com__\n      Backup dir: /opt/backups\n      (B4 instance)`\"]\n    server2[\"`__websites.example.com__\n      Target: /opt/www/webshop\n      Target: /opt/www/product`\"] --&gt; |pull| dst\n    lxd[\"`__minecraft.example.com__\n      Target: /opt/minecraft`\"] --&gt; |pull| dst</code></pre>"},{"location":"examples.html#config-files","title":"Config files","text":"<p>b4_backup.yml</p> <pre><code>---\nbackup_targets:\n  _default:  # (5)!\n    destination: /opt/backups\n    src_retention:\n      auto:\n        all: \"7days\"\n    dst_retention:  # (1)!\n      auto:\n        1day: 1month  # (2)!\n        1week: 1year\n        1month: forever\n\n  nextcloud.example.com:\n    source: ssh://root@nextcloud.example.com/opt/nextcloud\n\n  websites.example.com/webshop:\n    source: ssh://root@websites.example.com/opt/www/webshop\n\n  websites.example.com/product:\n    source: ssh://root@websites.example.com/opt/www/product\n\n  minecraft.example.com:\n    source: ssh://root@minecraft.example.com/opt/minecraft\n\ntimezone: utc\ndefault_targets:\n  - nextcloud.example.com\n  - websites.example.com  # (4)!\n  - minecraft.example.com\nlogging:\n  loggers:\n    root:\n      level: DEBUG  # (3)!\n</code></pre> <ol> <li>Retention rules are describing how long backups should be kept. Beside of just defining a lifetime, it's also possible to define a gradually decreasing density.</li> <li>This ruleset means that daily updates are kept for a month, then the density will be reduced to weekly updates which are kept for a year and so on.</li> <li>The logging section is a python logging.config.dictConfig which provides a powerful logging system. More info can be found in the official python documentation. https://docs.python.org/3/library/logging.config.html#dictionary-schema-details</li> <li>If you have multiple targets on the same server, you can define them in a single entry, because we have separated them by a slash. The Target name is just an arbitrary name.</li> <li>The <code>_default</code> keyword has a special meaning. If you omit values in another target, this value will be used. The <code>_default</code> keyword is also valid in <code>src_retention</code>, <code>dst_retention</code> and <code>subvolume_rules</code></li> </ol> <p>Daily Cronjob</p> /etc/cron.d/b4_backup_daily<pre><code>0 12 * * * root    b4 backup --name auto\n</code></pre>"},{"location":"examples.html#example-commands","title":"Example commands","text":"<p>Backup all targets defined in <code>default_targets</code> and use the retention ruleset <code>auto</code>:</p> <pre><code>b4 backup --name auto\n</code></pre> <p>A backup procedure contains the following stages:</p> <ul> <li>Create a snapshot on the source server   Source snapshots are located at <code>&lt;btrfs_mount_point\\&gt;/.b4_backup</code></li> <li>Get nearest parent snapshot which is available on source and destination side if present</li> <li>If yes: Send snapshots incrementally to the destination</li> <li>Apply retention rules on source and destination to delete old snapshots</li> </ul> <p>Backup <code>nextcloud.example.com</code> and use the default retention ruleset <code>manual</code>:</p> <pre><code>b4 backup --target nextcloud.example.com\n</code></pre> <p>Restore the snapshot <code>2023-08-28-13-37_manual</code> of target <code>nextcloud.example.com</code> using the default strategy (safe):</p> <pre><code>b4 restore 2023-08-28-13-37_manual --target nextcloud.example.com\n</code></pre> <p>This restore strategy only copies the snapshot back to the source snapshot location without touching the actual data. That is a good option, if you want to perform the actual restore yourself, or you only want to access old files without replacing the whole target.</p> <p>Restore the same snapshot using the REPLACE strategy:</p> <pre><code>b4 restore 2023-08-28-13-37_manual --target nextcloud.example.com --strategy replace\n</code></pre> <p>The replace strategy moves the target subvolume away and replaces it with the selected snapshot. The Nextcloud instance is being shut off before that. This action can be undone by the following command.</p> <pre><code>b4 restore REPLACE --target nextcloud.example.com --strategy replace\n</code></pre>"},{"location":"examples.html#push-backup","title":"Push backup","text":""},{"location":"examples.html#overview_1","title":"Overview","text":"<p>Here B4 Backup is installed on the server you want to backup and the snapshots are pushed to a backup server.</p> <pre><code>flowchart TD\n    server1[\"`__server.example.com__\n      Target path: /\n      (B4 instance)`\"] --&gt; |push| dst[\"`__backup.example.com__\n      Backup path: /opt/backups`\"]</code></pre>"},{"location":"examples.html#config-files_1","title":"Config files","text":"<p>b4_backup.yml</p> <pre><code>---\nbackup_targets:\n  _default:\n    destination: ssh://nextcloud@backup.example.com/home/nextcloud/backups\n    src_retention:\n      auto:\n        all: \"3\"\n    dst_retention:\n      auto:\n        1day: 1month\n        1week: 1year\n        1month: forever\n\n  nextcloud.example.com:\n    source: /opt/nextcloud\n\ntimezone: local\ndefault_targets:\n  - nextcloud.example.com\nlogging:\n  loggers:\n    root:\n      level: INFO\n</code></pre>"},{"location":"examples.html#example-commands_1","title":"Example commands","text":"<p>Backup target and use the retention ruleset <code>auto</code>:</p> <pre><code>b4 backup --name auto\n</code></pre>"},{"location":"examples.html#local-to-local","title":"Local to Local","text":""},{"location":"examples.html#overview_2","title":"Overview","text":"<p>In this scenario we are using B4 Backup to backup a local PC using an external hard drive. B4 Backup is installed on the PC and got a cronjob, which creates a snapshot of the full system every day, similar how tools like timeshift are doing it on a daily basis and keep it on the local system. The hard drive is encrypted using luks.</p> <p>If we eventually connect the external hard drive to the PC, we can run a sync command to send all unsended snapshots to the external hard drive and clean up the accumulated local ones.</p> <p>The default restore strategy is a <code>REPLACE</code> is a \"soft replace\", which means the active and mounted subvolume will be moved away instead of being deleted directly. This way we can restore the system while it's live and switch to the restored state by rebooting the system. The old moved subvolumes are deleted after a certain amount of time which is defined in the configuration.</p>"},{"location":"examples.html#config-files_2","title":"Config files","text":"<p>Create encrypted btrfs hard drive</p> <pre><code># In this case /dev/sdb is our external hard drive\n\n# Fill partition with random noise to improve security (optional)\nsudo dd if=/dev/urandom of=/dev/sdb bs=512k\n\nsudo cryptsetup luksFormat /dev/sdb\nsudo cryptsetup open /dev/sdb crypt_backup\nsudo mkfs.btrfs -L backups /dev/mapper/crypt_backup\n</code></pre> <p>b4_backup.yml</p> <pre><code>---\nbackup_targets:\n  mainpc.local:\n    destination: /media/username/backups\n    source: /btrfs_root  # (4)!\n    restore_strategy: REPLACE\n    replaced_target_ttl: 3days\n    src_snapshot_dir: .b4_backup\n    if_dst_dir_not_found: FAIL  # (5)!\n    src_retention:\n      auto:\n        all: \"7days\"\n    dst_retention:\n      auto:\n        1day: 1month\n        1week: 1year\n        1month: forever\n    subvolume_rules:  # (1)!\n      /home/username/.cache:  # (3)!\n        backup_strategy: SOURCE_ONLY\n        fallback_strategy: NEW\n      /home/username/.steam:\n        backup_strategy: IGNORE\n        fallback_strategy: NEW\n      /home/username/.local/share/Trash:\n        backup_strategy: IGNORE\n        fallback_strategy: NEW\n      .local/share/containers/storage:\n        backup_strategy: IGNORE\n      docker/btrfs/subvolumes:\n        backup_strategy: IGNORE\n      .b4_backup: # (2)!\n        backup_strategy: IGNORE\ndefault_targets:\n  - mainpc.local\ntimezone: local\n</code></pre> <ol> <li>Like the property name suggest, all items need to be a btrfs subvolume to be able to be matched ignored</li> <li>The default location of source snapshots (The point you want to backup) created by B4 Backup is <code>&lt;btrfs_mount_point&gt;/.b4_backup</code>. But because we want to backup at the btrfs mount point itself, we need to make sure doesn't start to recursively snapshot the snapshot location. That's why we need to explicitly exclude it here.</li> <li>Directories that often change, while they doesn't provide any value as a backup, shouldn't be copied to the destination. Caches are a perfect example for that. This way we can even restore the cache, as long as the snapshot is still present on source side.</li> <li>The btrfs_root is the true root of the btrfs subvolume, which is mounted to that point. The system rootfs is just a subvolume inside that.</li> <li>The default behavior of b4 is to create missing directories. But the destination dir can be just unmounted, so it need to throw an error, if that is the case.</li> </ol> <p>fstab</p> /etc/fstab<pre><code>TODO: Add fstab example\n</code></pre> <p>Cronjob: b4_backup_auto_snapshot</p> /etc/cron.d/b4_backup_daily_snapshot<pre><code>0 12 * * * root    b4 backup --name auto --offline\n</code></pre>"},{"location":"examples.html#example-commands_2","title":"Example commands","text":"<p>If you mount your external drive and want to send all snapshots created so far to the external drive, you can sync them with the following command:</p> <pre><code>b4 sync\n</code></pre>"},{"location":"install.html","title":"Installation","text":""},{"location":"install.html#install-b4-backup","title":"Install B4 Backup","text":""},{"location":"install.html#preconditions","title":"Preconditions","text":"<p>You need the following to be able to use B4 Backup properly:</p> <ul> <li>Python 3.12 or higher</li> <li>A btrfs partition on the machine you want to backup and your backup destination.</li> <li>btrfs-progs</li> </ul> Ubuntu, DebianFedora, Red Hat <pre><code>sudo apt install btrfs-progs\n</code></pre> <pre><code>sudo yum install btrfs-progs\n</code></pre>"},{"location":"install.html#using-pipx-recommended-for-users","title":"Using pipx (recommended for users)","text":"<ol> <li>Install pipx</li> </ol> Ubuntu, DebianFedora, Red Hat <pre><code>sudo apt install pipx\n</code></pre> <pre><code>sudo yum install pipx\n</code></pre> <ol> <li> <p>Install B4 Backup (Fill in token and name)</p> <pre><code>pipx install b4-backup\n</code></pre> </li> <li> <p>Next steps</p> <ul> <li>Examples</li> <li>CLI reference</li> <li>Config reference</li> </ul> </li> </ol>"},{"location":"install.html#using-poetry-for-developers","title":"Using poetry (for developers)","text":"<ol> <li> <p>Install poetry</p> </li> <li> <p>Clone the repository</p> </li> <li> <p>Setup poetry environment:</p> <pre><code>cd &lt;path_to_repo&gt;\n</code></pre> <p>Finally, install the package with poetry:</p> <pre><code>poetry install\n</code></pre> </li> <li> <p>Next steps</p> <p>Just switch into the poetry environment using <code>poetry shell</code>.</p> <ul> <li>Examples</li> <li>CLI reference</li> <li>Config reference</li> </ul> </li> </ol>"},{"location":"install.html#update-b4-backup","title":"Update B4 Backup","text":""},{"location":"install.html#using-pipx","title":"Using pipx","text":"<p>Similar to the installation, you upgrade B4 Backup like this:</p> <pre><code>pipx upgrade b4-backup\n</code></pre>"},{"location":"install.html#using-poetry","title":"Using poetry","text":"<pre><code>cd &lt;path_to_repo&gt;\ngit pull\npoetry install\n</code></pre>"},{"location":"install.html#uninstall-b4-backup","title":"Uninstall B4 Backup","text":""},{"location":"install.html#using-pipx_1","title":"Using pipx","text":"<pre><code>pipx uninstall b4-backup\n</code></pre>"},{"location":"install.html#using-poetry_1","title":"Using poetry","text":"<p>It's technically never installed, but you can remove it like that:</p> <pre><code>cd &lt;path_to_repo&gt;\npoetry env list\n# Delete every environment using\npoetry env remove &lt;env_name&gt;\ncd ..\nrm -rf b4_backup\n</code></pre>"},{"location":"terminology.html","title":"Terminology","text":""},{"location":"terminology.html#source-host","title":"Source Host","text":"<p>The source host is the host where the data is being backed up from. You specify a target location where the data you want to backup is laying. If you run a backup, the data is first incrementally copied to the source snapshot directory and then copied to the destination host.</p>"},{"location":"terminology.html#destination-host","title":"Destination Host","text":"<p>The destination host is the host where the data is being backed up to.</p>"},{"location":"terminology.html#backup-target","title":"Backup Target","text":"<p>The backup target contains the definition of the backup. It contains the source and destination host, the source and destination path, the retention rulesets, how to restore snapshots and more.</p>"},{"location":"terminology.html#retention-ruleset-retention-name","title":"Retention Ruleset / Retention Name","text":"<p>A retention ruleset is a set of rules that define how long a snapshot should be kept. A retention name is a string that identifies a retention ruleset.</p> <p>An example of a retention ruleset is the following:</p> <pre><code>auto:\n  1day: 2months\n  1week: 1year\n  1month: forever\n</code></pre> <p><code>auto</code> is the retention name. The ruleset defines that snapshots that daily snapshots should be kept for 2 months, after that the daily snapshots are deleted in a way, that only weekly snapshots are remaining, which are being kept for one year. After that, only monthly snapshots are kept forever.</p>"},{"location":"terminology.html#snapshot","title":"Snapshot","text":"<p>A Snapshot is an incremental recursive point-in-time copy of a btrfs subvolume. Snapshots are created by creating btrfs snapshots from all subvolumes at the target directory. They are stored on source side in the <code>src_snapshot_dir</code> and on destination side in the destination directory</p>"},{"location":"terminology.html#subvolume","title":"Subvolume","text":"<p>A snapshot can contain multiple btrfs subvolumes, if inside that directory are multiple subvolumes. A subvolume is a separate filesystem tree that can be mounted and accessed independently from the rest of the filesystem in btrfs.</p> <p>You can define rules for every subvolume inside the target directory for each backup target. This way you can define different retention rules for each subvolume and how to act on a restore, if the subvolumes are already deleted.</p>"},{"location":"reference/cli.html","title":"CLI reference","text":"<p>Backup and restore btrfs subvolumes using btrfs-progs.</p> <p>Usage:</p> <pre><code>$ b4 [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>-c, --config PATH</code>: Path to the config file  [default: ~/.config/b4_backup.yml]</li> <li><code>-o, --option TEXT</code>: Override values from the config</li> <li><code>-v, --version</code>: Print the current version and exit</li> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>backup</code>: Perform backups on specified targets.</li> <li><code>list</code>: List all snapshots for the specified targets.</li> <li><code>clean</code>: Apply the targets retention ruleset...</li> <li><code>delete</code>: Delete a specific snapshot from the source...</li> <li><code>delete-all</code>: Delete all local and remote backups of the...</li> <li><code>restore</code>: Restore one or more targets based on a...</li> <li><code>sync</code>: Send pending snapshots to the destination.</li> <li><code>tools</code>: Helpful cli commands, that are too...</li> </ul>"},{"location":"reference/cli.html#b4-backup","title":"<code>b4 backup</code>","text":"<p>Perform backups on specified targets. If no target is specified, the default targets defined in the config will be used.</p> <p>Usage:</p> <pre><code>$ b4 backup [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-t, --target TEXT</code>: Selected targets to backup</li> <li><code>-n, --name TEXT</code>: Name suffix (and retention ruleset) for this backup  [default: manual]</li> <li><code>--source-only / --no-source-only</code>: Perform actions on source side only  [default: no-source-only]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/cli.html#b4-list","title":"<code>b4 list</code>","text":"<p>List all snapshots for the specified targets.</p> <p>Usage:</p> <pre><code>$ b4 list [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-t, --target TEXT</code>: Selected targets to backup</li> <li><code>--source / --no-source</code>: List snapshots on source host  [default: no-source]</li> <li><code>--destination / --no-destination</code>: List snapshots on destination host  [default: no-destination]</li> <li><code>--format [rich|json|raw]</code>: Output format  [default: rich]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/cli.html#b4-clean","title":"<code>b4 clean</code>","text":"<p>Apply the targets retention ruleset without performing a backup.</p> <p>Usage:</p> <pre><code>$ b4 clean [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-t, --target TEXT</code>: Selected targets to backup</li> <li><code>--source-only / --no-source-only</code>: Perform actions on source side only  [default: no-source-only]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/cli.html#b4-delete","title":"<code>b4 delete</code>","text":"<p>Delete a specific snapshot from the source and/or destination.</p> <p>Usage:</p> <pre><code>$ b4 delete [OPTIONS] SNAPSHOT_NAME\n</code></pre> <p>Arguments:</p> <ul> <li><code>SNAPSHOT_NAME</code>: Name of the snapshot you want to restore  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-t, --target TEXT</code>: Selected targets to backup</li> <li><code>--source / --no-source</code>: Delete from source host  [default: no-source]</li> <li><code>--destination / --no-destination</code>: Delete from destination host  [default: no-destination]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/cli.html#b4-delete-all","title":"<code>b4 delete-all</code>","text":"<p>Delete all local and remote backups of the specified target/retention ruleset combination. Equivalent to an \"all: 0\" rule.</p> <p>Usage:</p> <pre><code>$ b4 delete-all [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-t, --target TEXT</code>: Selected targets to backup</li> <li><code>-r, --retention TEXT</code>: Name suffix (and retention ruleset) for this backup  [default: ALL]</li> <li><code>--force / --no-force</code>: Skip confirmation prompt  [default: no-force]</li> <li><code>--source / --no-source</code>: Delete from source host  [default: no-source]</li> <li><code>--destination / --no-destination</code>: Delete from destination host  [default: no-destination]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/cli.html#b4-restore","title":"<code>b4 restore</code>","text":"<p>Restore one or more targets based on a previously created snapshot. You can revert a REPLACE restore by using REPLACE als snapshot name and strategy.</p> <p>Usage:</p> <pre><code>$ b4 restore [OPTIONS] SNAPSHOT_NAME\n</code></pre> <p>Arguments:</p> <ul> <li><code>SNAPSHOT_NAME</code>: Name of the snapshot you want to restore  [required]</li> </ul> <p>Options:</p> <ul> <li><code>-t, --target TEXT</code>: Selected targets to backup</li> <li><code>--strategy [safe|replace]</code>: Restore strategy or procedure to apply</li> <li><code>--source-only / --no-source-only</code>: Perform actions on source side only  [default: no-source-only]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/cli.html#b4-sync","title":"<code>b4 sync</code>","text":"<p>Send pending snapshots to the destination.</p> <p>Usage:</p> <pre><code>$ b4 sync [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>-t, --target TEXT</code>: Selected targets to backup</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/cli.html#b4-tools","title":"<code>b4 tools</code>","text":"<p>Helpful cli commands, that are too specific to be in the main part of the code.</p> <p>Some parts here may be untested.</p> <p>Usage:</p> <pre><code>$ b4 tools [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>dump-config</code>: Return the fully interpolated configuration.</li> <li><code>update-config</code>: Updates the b4 config based on the new...</li> </ul>"},{"location":"reference/cli.html#b4-tools-dump-config","title":"<code>b4 tools dump-config</code>","text":"<p>Return the fully interpolated configuration. For debugging.</p> <p>Usage:</p> <pre><code>$ b4 tools dump-config [OPTIONS]\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/cli.html#b4-tools-update-config","title":"<code>b4 tools update-config</code>","text":"<p>Updates the b4 config based on the new targets list parameter.</p> <p>Targets that are not mentioned in the new targets list, aren't removed, but the source attribute will become None, until every backup is eventually deleted or cleaned.</p> <p>You need to provide the config updates in a format like this:</p> <p>ruaml.yaml required.</p> <p>Usage:</p> <pre><code>$ b4 tools update-config [OPTIONS] NEW_TARGETS\n</code></pre> <p>Arguments:</p> <ul> <li><code>NEW_TARGETS</code>: JSON object containing 'target_name: source'  [required]</li> </ul> <p>Options:</p> <ul> <li><code>--dry-run / --no-dry-run</code>: Just print the new config instead of actually updating the config file  [default: no-dry-run]</li> <li><code>--delete-source / --no-delete-source</code>: Delete all backups on source side  [default: no-delete-source]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"reference/code/config_schema.html","title":"Config schema","text":"<p>This module contains the config structure and it's default values.</p> <p>The config is using the YAML syntax and this file describes the structure of it.</p>"},{"location":"reference/code/config_schema.html#b4_backup.config_schema.BackupTarget","title":"BackupTarget  <code>dataclass</code>","text":"<pre><code>BackupTarget(\n    source=II(f\"..{DEFAULT}.source\"),\n    destination=II(f\"..{DEFAULT}.destination\"),\n    if_dst_dir_not_found=II(\n        f\"..{DEFAULT}.if_dst_dir_not_found\"\n    ),\n    restore_strategy=II(f\"..{DEFAULT}.restore_strategy\"),\n    src_snapshot_dir=II(f\"..{DEFAULT}.src_snapshot_dir\"),\n    src_retention=dict(),\n    dst_retention=dict(),\n    replaced_target_ttl=II(\n        f\"..{DEFAULT}.replaced_target_ttl\"\n    ),\n    subvolume_rules=II(f\"..{DEFAULT}.subvolume_rules\"),\n)\n</code></pre> <p>Defines a single backup target.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | None</code> <p>Path or URL you want to backup. Needs to be a btrfs subvolume</p> <code>II(f'..{DEFAULT}.source')</code> <code>destination</code> <code>str | None</code> <p>Path or URL where you want to send snapshots. If None, snapshots will only be on source side</p> <code>II(f'..{DEFAULT}.destination')</code> <code>restore_strategy</code> <code>TargetRestoreStrategy</code> <p>Default procedure to restore a backup</p> <code>II(f'..{DEFAULT}.restore_strategy')</code> <code>src_snapshot_dir</code> <code>Path</code> <p>Directory where source snapshots relative to the mount point of the btrfs volume are located</p> <code>II(f'..{DEFAULT}.src_snapshot_dir')</code> <code>src_retention</code> <code>dict[str, dict[str, str]]</code> <p>Retention rules for snapshots located at the source</p> <code>dict()</code> <code>dst_retention</code> <code>dict[str, dict[str, str]]</code> <p>Retention rules for snapshots located at the destination</p> <code>dict()</code> <code>replaced_target_ttl</code> <code>str</code> <p>The minimum time the old replaced subvolume should be kept</p> <code>II(f'..{DEFAULT}.replaced_target_ttl')</code> <code>subvolume_rules</code> <code>dict[str, TargetSubvolume]</code> <p>Contains rules for how to handle the subvolumes of a target</p> <code>II(f'..{DEFAULT}.subvolume_rules')</code>"},{"location":"reference/code/config_schema.html#b4_backup.config_schema.BaseConfig","title":"BaseConfig  <code>dataclass</code>","text":"<pre><code>BaseConfig(\n    backup_targets=lambda: {\n        DEFAULT: BackupTarget(\n            source=None,\n            destination=None,\n            if_dst_dir_not_found=OnDestinationDirNotFound.CREATE,\n            restore_strategy=TargetRestoreStrategy.SAFE,\n            src_snapshot_dir=Path(\".b4_backup\"),\n            src_retention={DEFAULT: {\"all\": \"1\"}},\n            dst_retention={DEFAULT: {\"all\": \"forever\"}},\n            replaced_target_ttl=\"24hours\",\n            subvolume_rules={\n                DEFAULT: TargetSubvolume(\n                    backup_strategy=SubvolumeBackupStrategy.FULL,\n                    fallback_strategy=SubvolumeFallbackStrategy.DROP,\n                ),\n                \"/\": TargetSubvolume(),\n            },\n        )\n    }(),\n    default_targets=list(),\n    timezone=\"utc\",\n    logging=II(\n        \"oc.create:${from_file:\"\n        + str(\n            Path(__file__).parent\n            / \"default_logging_config.yml\"\n        )\n        + \"}\"\n    ),\n    config_path=Path(\"~/.config/b4_backup.yml\"),\n)\n</code></pre> <p>The root level of the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>backup_targets</code> <code>dict[str, BackupTarget]</code> <p>An object containing all targets to backup</p> <code>lambda: {DEFAULT: BackupTarget(source=None, destination=None, if_dst_dir_not_found=CREATE, restore_strategy=SAFE, src_snapshot_dir=Path('.b4_backup'), src_retention={DEFAULT: {'all': '1'}}, dst_retention={DEFAULT: {'all': 'forever'}}, replaced_target_ttl='24hours', subvolume_rules={DEFAULT: TargetSubvolume(backup_strategy=FULL, fallback_strategy=DROP), '/': TargetSubvolume()})}()</code> <code>default_targets</code> <code>list[str]</code> <p>List of default targets to use if not specified</p> <code>list()</code> <code>timezone</code> <code>str</code> <p>Timezone to use</p> <code>'utc'</code> <code>logging</code> <code>dict[str, Any]</code> <p>Python logging configuration settings (logging.config.dictConfig).</p> <code>II('oc.create:${from_file:' + str(parent / 'default_logging_config.yml') + '}')</code>"},{"location":"reference/code/config_schema.html#b4_backup.config_schema.BaseConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Used for validation of the values.</p> Source code in <code>b4_backup/config_schema.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Used for validation of the values.\"\"\"\n    options = set(self.backup_targets) - {DEFAULT}\n    for target in self.default_targets:\n        if not any(PurePath(x).is_relative_to(target) for x in options):\n            raise omegaconf.errors.ValidationError(\n                textwrap.dedent(\n                    f\"\"\"\\\n                    Item '{target}' is not in 'backup_targets' but defined in 'default_targets'\n                        full_key: default_targets\n                        object_type={self.__class__.__name__}\"\"\"\n                )\n            )\n</code></pre>"},{"location":"reference/code/config_schema.html#b4_backup.config_schema.OnDestinationDirNotFound","title":"OnDestinationDirNotFound","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>How to behave, if the destination directory does not exist.</p> <p>Attributes:</p> Name Type Description <code>CREATE</code> <p>Create the missing directory structure and proceed without an error.</p> <code>FAIL</code> <p>Throw an error and stop execution.</p>"},{"location":"reference/code/config_schema.html#b4_backup.config_schema.SubvolumeBackupStrategy","title":"SubvolumeBackupStrategy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Backup strategy for subvolumes.</p> <p>Attributes:</p> Name Type Description <code>IGNORE</code> <p>The subvolume will be ignored during the backup</p> <code>SOURCE_ONLY</code> <p>The subvolume will be kept only on source and not sent to destination</p> <code>FULL</code> <p>The subvolume will be sent to destination</p>"},{"location":"reference/code/config_schema.html#b4_backup.config_schema.SubvolumeFallbackStrategy","title":"SubvolumeFallbackStrategy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Fallback strategy for subvolumes on a restore if the backup subvolume is already deleted.</p> <p>Attributes:</p> Name Type Description <code>DROP</code> <p>The subvolume is lost after a restore (Use case: Docker artifacts or everywhere else where btrfs subvolumes are created dynamically)</p> <code>NEW</code> <p>An empty subvolume is created at that place (Use case: Cache directories)</p> <code>KEEP</code> <p>The old subvolume will be copied at the new place, if doesn't exist, a new one will be created (Use case: Steam library)</p>"},{"location":"reference/code/config_schema.html#b4_backup.config_schema.TargetRestoreStrategy","title":"TargetRestoreStrategy","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Specifies the restore procedure to be used.</p> <p>Attributes:</p> Name Type Description <code>SAFE</code> <p>Just copy the snapshot back to the source snapshot directory without touching the target directory</p> <code>REPLACE</code> <p>Bases safe, but also replace the target subvolumes with the copied one. Works by moving the original target away and then copy the snapshot to that place. Revertable by using the REPLACE snapshot name.</p>"},{"location":"reference/code/config_schema.html#b4_backup.config_schema.TargetSubvolume","title":"TargetSubvolume  <code>dataclass</code>","text":"<pre><code>TargetSubvolume(\n    backup_strategy=II(f\"..{DEFAULT}.backup_strategy\"),\n    fallback_strategy=II(f\"..{DEFAULT}.fallback_strategy\"),\n)\n</code></pre> <p>Defines how to handle a specific subvolume in a target.</p> <p>Parameters:</p> Name Type Description Default <code>backup_strategy</code> <code>SubvolumeBackupStrategy</code> <p>How to handle the subvolume during backup</p> <code>II(f'..{DEFAULT}.backup_strategy')</code> <code>fallback_strategy</code> <code>SubvolumeFallbackStrategy</code> <p>How to handle the subvolume during restore if the backup subvolume is already deleted</p> <code>II(f'..{DEFAULT}.fallback_strategy')</code>"},{"location":"reference/code/exceptions.html","title":"Exceptions","text":"<p>Contains all custom exceptions used in this program.</p>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.BaseBtrfsBackupError","title":"BaseBtrfsBackupError","text":"<p>               Bases: <code>Exception</code></p> <p>Base of all custom exceptions.</p>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.BtrfsPartitionNotFoundError","title":"BtrfsPartitionNotFoundError","text":"<p>               Bases: <code>BaseBtrfsBackupError</code></p> <p>Raised, if the target location is not a valid btrfs partition.</p>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.BtrfsSubvolumeNotFoundError","title":"BtrfsSubvolumeNotFoundError","text":"<p>               Bases: <code>BaseBtrfsBackupError</code></p> <p>Raised, if a BTRFS subvolume does not exist.</p>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.DestinationDirectoryNotFoundError","title":"DestinationDirectoryNotFoundError","text":"<p>               Bases: <code>BaseBtrfsBackupError</code></p> <p>Raised, if the destination is not found and configured to fail.</p>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.FailedProcessError","title":"FailedProcessError","text":"<pre><code>FailedProcessError(cmd, stdout='', stderr='')\n</code></pre> <p>               Bases: <code>BaseBtrfsBackupError</code></p> <p>Raised, if a process returns a non-zero return code.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>list[str]</code> <p>failed command.</p> required <code>stdout</code> <code>str</code> <p>standard output of that process.</p> <code>''</code> <code>stderr</code> <code>str</code> <p>standard error of that process.</p> <code>''</code> Source code in <code>b4_backup/exceptions.py</code> <pre><code>def __init__(self, cmd: list[str], stdout: str = \"\", stderr: str = \"\"):\n    \"\"\"\n    Args:\n        cmd: failed command.\n        stdout: standard output of that process.\n        stderr: standard error of that process.\n    \"\"\"\n    self.cmd = cmd\n    self.stdout = stdout\n    self.stderr = stderr\n\n    super().__init__(\n        \"The following process exited with a non-zero error:\\n\"\n        f\"===  CMD   ===\\n{' '.join(cmd)}\\n============\\n\"\n        f\"=== STDOUT ===\\n{stdout}============\\n\"\n        f\"=== STDERR ===\\n{stderr}============\\n\"\n    )\n</code></pre>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.InvalidConnectionUrlError","title":"InvalidConnectionUrlError","text":"<p>               Bases: <code>BaseBtrfsBackupError</code></p> <p>Raised, if the connection url is malformed.</p>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.InvalidRetentionRuleError","title":"InvalidRetentionRuleError","text":"<p>               Bases: <code>BaseBtrfsBackupError</code></p> <p>Raised, if the retention rule string is malformed.</p>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.SnapshotNotFoundError","title":"SnapshotNotFoundError","text":"<p>               Bases: <code>BaseBtrfsBackupError</code></p> <p>Raised, if a BTRFS backup snapshot does not exist.</p>"},{"location":"reference/code/exceptions.html#b4_backup.exceptions.UnknownProtocolError","title":"UnknownProtocolError","text":"<p>               Bases: <code>InvalidConnectionUrlError</code></p> <p>Raised, if an unsupported protocol is used.</p>"},{"location":"reference/code/utils.html","title":"Utils","text":"<p>A collection of Helper functions.</p>"},{"location":"reference/code/utils.html#b4_backup.utils.contains_path","title":"contains_path","text":"<pre><code>contains_path(path, sub_path)\n</code></pre> <p>Check if a subpath is included in another path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PurePath</code> <p>Path you want to check</p> required <code>sub_path</code> <code>PurePath</code> <p>Subpath that should be included in path.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if path contains subpath</p> Source code in <code>b4_backup/utils.py</code> <pre><code>def contains_path(path: PurePath, sub_path: PurePath) -&gt; bool:\n    \"\"\"\n    Check if a subpath is included in another path.\n\n    Args:\n        path: Path you want to check\n        sub_path: Subpath that should be included in path.\n\n    Returns:\n        True if path contains subpath\n    \"\"\"\n    return any(\n        slice == sub_path.parts\n        for slice in zip(*[path.parts[i:] for i in range(len(sub_path.parts))])\n    )\n</code></pre>"},{"location":"reference/code/utils.html#b4_backup.utils.load_config","title":"load_config","text":"<pre><code>load_config(config_path=DEFAULT_CONFIG, overrides=None)\n</code></pre> <p>Reads the config file and returns a config dataclass.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path</code> <p>Path of the config file</p> <code>DEFAULT_CONFIG</code> <code>overrides</code> <code>list[str] | None</code> <p>A list of dot list entries, which can override the values in the config. Used for CLI.</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseConfig</code> <p>Config object</p> Source code in <code>b4_backup/utils.py</code> <pre><code>def load_config(\n    config_path: Path = DEFAULT_CONFIG, overrides: list[str] | None = None\n) -&gt; BaseConfig:\n    \"\"\"\n    Reads the config file and returns a config dataclass.\n\n    Args:\n        config_path: Path of the config file\n        overrides:\n            A list of dot list entries, which can override the values in the config.\n            Used for CLI.\n\n    Returns:\n        Config object\n    \"\"\"\n    overrides = overrides or []\n\n    config_path = config_path.expanduser()\n    config_path.parent.mkdir(exist_ok=True, parents=True)\n    _ = config_path.exists() or config_path.touch()\n\n    if not OmegaConf.has_resolver(\"from_file\"):\n        OmegaConf.register_new_resolver(\"from_file\", resolve_from_file)\n        OmegaConf.register_new_resolver(\"parent_dir\", resolve_parent_dir)\n\n    base_conf = OmegaConf.merge(\n        OmegaConf.structured(BaseConfig),\n        OmegaConf.load(config_path),\n        OmegaConf.from_dotlist(overrides),\n    )\n\n    # Templates shouldn't fail, if there is a value missing\n    base_conf.backup_targets[DEFAULT].source = \"NONE\"\n\n    # pylance doesn't understand here that it's actually a config_schema.BaseConfig type\n    base_conf_instance: BaseConfig = OmegaConf.to_container(  # type: ignore\n        base_conf, structured_config_mode=SCMode.INSTANTIATE, resolve=True\n    )\n\n    base_conf_instance.config_path = config_path\n\n    # retention rulesets shouldn't do a nested merge\n    # That's why I do a shallow update here manually\n    _copy_from_default_retention(base_conf_instance)\n\n    return base_conf_instance\n</code></pre>"},{"location":"reference/code/utils.html#b4_backup.utils.resolve_from_file","title":"resolve_from_file","text":"<pre><code>resolve_from_file(path)\n</code></pre> <p>This resolver (from_file) can be used in OmegaConf configs to use the raw content of a file as an input.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Input file path</p> required <p>Returns:</p> Type Description <code>str</code> <p>File content</p> Source code in <code>b4_backup/utils.py</code> <pre><code>def resolve_from_file(path: str) -&gt; str:\n    \"\"\"\n    This resolver (from_file) can be used in OmegaConf configs to use the raw content of a file as an input.\n\n    Args:\n        path: Input file path\n\n    Returns:\n        File content\n    \"\"\"\n    return Path(path).read_text(encoding=\"utf8\").strip()\n</code></pre>"},{"location":"reference/code/utils.html#b4_backup.utils.resolve_parent_dir","title":"resolve_parent_dir","text":"<pre><code>resolve_parent_dir(path)\n</code></pre> <p>This resolver (parent_dir) can be used in OmegaConf configs to return the parent directory or the directory of a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Name of the file or directory</p> required <p>Returns:</p> Type Description <code>str</code> <p>Parent directory</p> Source code in <code>b4_backup/utils.py</code> <pre><code>def resolve_parent_dir(path: str) -&gt; str:\n    \"\"\"\n    This resolver (parent_dir) can be used in OmegaConf configs to return the parent directory or the directory of a file.\n\n    Args:\n        path: Name of the file or directory\n\n    Returns:\n        Parent directory\n    \"\"\"\n    return str(PurePath(path).parent)\n</code></pre>"},{"location":"reference/code/utils.html#b4_backup.utils.rich_handler","title":"rich_handler","text":"<pre><code>rich_handler()\n</code></pre> <p>Used in the logging config to use a customized RichHandler.</p> Source code in <code>b4_backup/utils.py</code> <pre><code>def rich_handler() -&gt; RichHandler:\n    \"\"\"Used in the logging config to use a customized RichHandler.\"\"\"\n    return RichHandler(console=CONSOLE)\n</code></pre>"},{"location":"reference/code/main/b4_backup.html","title":"B4 backup","text":""},{"location":"reference/code/main/b4_backup.html#b4_backup.main.b4_backup.B4Backup","title":"B4Backup  <code>dataclass</code>","text":"<pre><code>B4Backup(timezone=BaseConfig.timezone)\n</code></pre> <p>Main controller class for the backups. Does the backups and stuff.</p> <p>Parameters:</p> Name Type Description Default <code>timezone</code> <code>str</code> <p>Timezone to use</p> <code>timezone</code>"},{"location":"reference/code/main/b4_backup.html#b4_backup.main.b4_backup.B4Backup.backup","title":"backup","text":"<pre><code>backup(src_host, dst_host, snapshot_name)\n</code></pre> <p>Performs a backup for a single target.</p> <p>dst_host can be none. In this case nothing will be sent and only a snapshot + clean up on source side is performed.</p> <p>Parameters:</p> Name Type Description Default <code>src_host</code> <code>SourceBackupTargetHost</code> <p>An active source host instance</p> required <code>dst_host</code> <code>DestinationBackupTargetHost | None</code> <p>An active destination host instance</p> required <code>snapshot_name</code> <code>str</code> <p>The name of the new snapshot</p> required Source code in <code>b4_backup/main/b4_backup.py</code> <pre><code>def backup(\n    self,\n    src_host: SourceBackupTargetHost,\n    dst_host: DestinationBackupTargetHost | None,\n    snapshot_name: str,\n) -&gt; None:\n    \"\"\"\n    Performs a backup for a single target.\n\n    dst_host can be none. In this case nothing will be sent and only a snapshot + clean up on source side is performed.\n\n    Args:\n        src_host: An active source host instance\n        dst_host: An active destination host instance\n        snapshot_name: The name of the new snapshot\n    \"\"\"\n    log.info(\"Snapshot name: %s\", snapshot_name)\n\n    src_host.create_snapshot(snapshot_name)\n\n    if dst_host:\n        src_host.send_snapshot(dst_host, snapshot_name)\n\n    retention_name = ChoiceSelector([self._extract_retention_name(snapshot_name)])\n    self.clean(\n        src_host=src_host,\n        dst_host=dst_host,\n        retention_names=retention_name,\n    )\n</code></pre>"},{"location":"reference/code/main/b4_backup.html#b4_backup.main.b4_backup.B4Backup.clean","title":"clean","text":"<pre><code>clean(\n    src_host,\n    dst_host=None,\n    retention_names=ChoiceSelector([\"ALL\"]),\n)\n</code></pre> <p>Apply a retention ruleset on the selected targets.</p> <p>Parameters:</p> Name Type Description Default <code>src_host</code> <code>SourceBackupTargetHost</code> <p>An active source host instance</p> required <code>dst_host</code> <code>DestinationBackupTargetHost | None</code> <p>An active destination host instance</p> <code>None</code> <code>retention_names</code> <code>ChoiceSelector</code> <p>Name suffix of this backup (retention ruleset)</p> <code>ChoiceSelector(['ALL'])</code> Source code in <code>b4_backup/main/b4_backup.py</code> <pre><code>def clean(\n    self,\n    src_host: SourceBackupTargetHost,\n    dst_host: DestinationBackupTargetHost | None = None,\n    retention_names: ChoiceSelector = ChoiceSelector([\"ALL\"]),\n) -&gt; None:\n    \"\"\"\n    Apply a retention ruleset on the selected targets.\n\n    Args:\n        src_host: An active source host instance\n        dst_host: An active destination host instance\n        retention_names: Name suffix of this backup (retention ruleset)\n    \"\"\"\n    self._clean_target(src_host, dst_host, retention_names)\n    self._clean_replace(src_host)\n    self._clean_empty_dirs(src_host, dst_host)\n</code></pre>"},{"location":"reference/code/main/b4_backup.html#b4_backup.main.b4_backup.B4Backup.delete","title":"delete","text":"<pre><code>delete(host, snapshot_name)\n</code></pre> <p>Delete a specific snapshot from a specific target/host.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>BackupTargetHost</code> <p>the selected target host</p> required <code>snapshot_name</code> <code>str</code> <p>The name of the snapshot to delete</p> required Source code in <code>b4_backup/main/b4_backup.py</code> <pre><code>def delete(\n    self,\n    host: BackupTargetHost,\n    snapshot_name: str,\n) -&gt; None:\n    \"\"\"\n    Delete a specific snapshot from a specific target/host.\n\n    Args:\n        host: the selected target host\n        snapshot_name: The name of the snapshot to delete\n    \"\"\"\n    snapshots = host.snapshots()\n\n    if snapshot_name not in snapshots:\n        log.warning(\"Snapshot %s does not exist on %s\", snapshot_name, host.type)\n        return\n\n    host.delete_snapshot(snapshots[snapshot_name])\n</code></pre>"},{"location":"reference/code/main/b4_backup.html#b4_backup.main.b4_backup.B4Backup.delete_all","title":"delete_all","text":"<pre><code>delete_all(host, retention_names=ChoiceSelector(['ALL']))\n</code></pre> <p>Delete all snapshots from a specific target/host/retention item.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>BackupTargetHost</code> <p>the selected target host</p> required <code>retention_names</code> <code>ChoiceSelector</code> <p>The retention names the snapshots have to contain</p> <code>ChoiceSelector(['ALL'])</code> Source code in <code>b4_backup/main/b4_backup.py</code> <pre><code>def delete_all(\n    self,\n    host: BackupTargetHost,\n    retention_names: ChoiceSelector = ChoiceSelector([\"ALL\"]),\n) -&gt; None:\n    \"\"\"\n    Delete all snapshots from a specific target/host/retention item.\n\n    Args:\n        host: the selected target host\n        retention_names: The retention names the snapshots have to contain\n    \"\"\"\n    resolved_retention_names = set(retention_names.resolve_retention_name(host.snapshots()))\n\n    for snapshot_name, snapshot in host.snapshots().items():\n        if self._extract_retention_name(snapshot_name) not in resolved_retention_names:\n            continue\n\n        host.delete_snapshot(snapshot)\n</code></pre>"},{"location":"reference/code/main/b4_backup.html#b4_backup.main.b4_backup.B4Backup.generate_snapshot_name","title":"generate_snapshot_name","text":"<pre><code>generate_snapshot_name(name=None)\n</code></pre> <p>Generate a name for a new snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Retention rule name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Name for a snapshot</p> Source code in <code>b4_backup/main/b4_backup.py</code> <pre><code>def generate_snapshot_name(self, name: str | None = None) -&gt; str:\n    \"\"\"\n    Generate a name for a new snapshot.\n\n    Args:\n        name: Retention rule name\n\n    Returns:\n        Name for a snapshot\n    \"\"\"\n    snapshot_name = arrow.utcnow().to(self.timezone).format(self._timestamp_fmt)\n\n    if name:\n        snapshot_name += f\"_{name}\"\n\n    return snapshot_name\n</code></pre>"},{"location":"reference/code/main/b4_backup.html#b4_backup.main.b4_backup.B4Backup.restore","title":"restore","text":"<pre><code>restore(src_host, dst_host, snapshot_name, strategy)\n</code></pre> <p>Restore a snapshot to one or more targets.</p> <p>Parameters:</p> Name Type Description Default <code>src_host</code> <code>SourceBackupTargetHost</code> <p>An active source host instance</p> required <code>dst_host</code> <code>DestinationBackupTargetHost | None</code> <p>An active destination host instance</p> required <code>snapshot_name</code> <code>str</code> <p>Name of the snapshot you want to restore</p> required <code>strategy</code> <code>TargetRestoreStrategy</code> <p>Restore strategy or procedure to apply</p> required Source code in <code>b4_backup/main/b4_backup.py</code> <pre><code>def restore(\n    self,\n    src_host: SourceBackupTargetHost,\n    dst_host: DestinationBackupTargetHost | None,\n    snapshot_name: str,\n    strategy: TargetRestoreStrategy,\n) -&gt; None:\n    \"\"\"\n    Restore a snapshot to one or more targets.\n\n    Args:\n        src_host: An active source host instance\n        dst_host: An active destination host instance\n        snapshot_name: Name of the snapshot you want to restore\n        strategy: Restore strategy or procedure to apply\n    \"\"\"\n    if snapshot_name == \"REPLACE\":\n        if strategy != TargetRestoreStrategy.REPLACE:\n            raise exceptions.SnapshotNotFoundError(\n                \"REPLACE can only be restored using REPLACE restore strategy\"\n            )\n\n        log.info(\"Reverting last REPLACE restore\")\n        self._rollback_replace(src_host)\n\n    elif strategy == TargetRestoreStrategy.REPLACE:\n        log.info(\"Using REPLACE restore strategy\")\n        self._restore_replace(src_host, dst_host, snapshot_name)\n\n    else:\n        log.info(\"Using SAFE restore strategy\")\n        self._restore_safe(src_host, dst_host, snapshot_name)\n</code></pre>"},{"location":"reference/code/main/b4_backup.html#b4_backup.main.b4_backup.B4Backup.sync","title":"sync","text":"<pre><code>sync(src_host, dst_host)\n</code></pre> <p>Send unsended snapshots to the destination and clean them.</p> <p>Parameters:</p> Name Type Description Default <code>src_host</code> <code>SourceBackupTargetHost</code> <p>An active source host instance</p> required <code>dst_host</code> <code>DestinationBackupTargetHost</code> <p>An active destination host instance</p> required Source code in <code>b4_backup/main/b4_backup.py</code> <pre><code>def sync(\n    self,\n    src_host: SourceBackupTargetHost,\n    dst_host: DestinationBackupTargetHost,\n) -&gt; None:\n    \"\"\"\n    Send unsended snapshots to the destination and clean them.\n\n    Args:\n        src_host: An active source host instance\n        dst_host: An active destination host instance\n    \"\"\"\n    self.clean(src_host, dst_host)\n\n    src_snapshots = src_host.snapshots()\n    dst_snapshots = dst_host.snapshots()\n\n    for snapshot_name in src_snapshots.keys() - dst_snapshots.keys():\n        src_host.send_snapshot(dst_host, snapshot_name)\n\n    self.clean(src_host, dst_host)\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html","title":"Backup target host","text":""},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost","title":"BackupTargetHost  <code>dataclass</code>","text":"<pre><code>BackupTargetHost(\n    name, target_config, snapshot_dir, connection\n)\n</code></pre> <p>Describes a host containing backups. Can be source and destination.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the TargetHost</p> <code>target_config</code> <code>BackupTarget</code> <p>The Config object describing this BackupTarget</p> <code>snapshot_dir</code> <code>BackupHostPath</code> <p>Path to the snapshots of this target on this host</p> <code>connection</code> <code>Connection</code> <p>Connection object to the host</p>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.type","title":"type  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>type\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>if it's a source or destination host.</p>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.delete_snapshot","title":"delete_snapshot","text":"<pre><code>delete_snapshot(snapshot, subvolumes=None)\n</code></pre> <p>Delete a snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot</code> <code>Snapshot</code> <p>Snapshot to delete</p> required <code>subvolumes</code> <code>list[BackupHostPath] | None</code> <p>Subvolumes to delete. If None, all subvolumes are deleted</p> <code>None</code> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def delete_snapshot(\n    self,\n    snapshot: Snapshot,\n    subvolumes: list[BackupHostPath] | None = None,\n) -&gt; None:\n    \"\"\"\n    Delete a snapshot.\n\n    Args:\n        snapshot: Snapshot to delete\n        subvolumes: Subvolumes to delete. If None, all subvolumes are deleted\n    \"\"\"\n    if subvolumes is None:\n        subvolumes = snapshot.subvolumes\n\n    for subvolume in snapshot.subvolumes:\n        if subvolume not in subvolumes:\n            continue\n\n        subvolume_dir = snapshot.base_path / snapshot.name / subvolume\n\n        log.info(\"Delete snapshot %s on %s\", str(snapshot.name / subvolume), self.type)\n        self.connection.run_process([\"btrfs\", \"subvolume\", \"delete\", str(subvolume_dir)])\n\n    if subvolumes == snapshot.subvolumes:\n        (snapshot.base_path / snapshot.name).rmdir()\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.filter_subvolumes_by_backup_strategy","title":"filter_subvolumes_by_backup_strategy","text":"<pre><code>filter_subvolumes_by_backup_strategy(\n    subvolumes, backup_strategies\n)\n</code></pre> <p>Retrieve subvolumes that are marked as source only from a snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>subvolumes</code> <code>Iterable[BackupHostPath]</code> <p>Subvolumes to filter</p> required <code>backup_strategies</code> <code>set[SubvolumeBackupStrategy]</code> <p>Backup strategies to search for</p> required <p>Returns:</p> Type Description <code>None</code> <p>Generator of subvolumes</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def filter_subvolumes_by_backup_strategy(\n    self,\n    subvolumes: Iterable[BackupHostPath],\n    backup_strategies: set[SubvolumeBackupStrategy],\n) -&gt; Generator[BackupHostPath, None, None]:\n    \"\"\"\n    Retrieve subvolumes that are marked as source only from a snapshot.\n\n    Args:\n        subvolumes: Subvolumes to filter\n        backup_strategies: Backup strategies to search for\n\n    Returns:\n        Generator of subvolumes\n    \"\"\"\n    return self._filter_subvolumes(\n        (self.path(\"/\") / x for x in subvolumes),\n        [\n            PurePath(k)\n            for k, v in self.target_config.subvolume_rules.items()\n            if v.backup_strategy in backup_strategies\n        ],\n    )\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.from_destination_host","title":"from_destination_host  <code>classmethod</code>","text":"<pre><code>from_destination_host(\n    target_name, target_config, connection\n)\n</code></pre> <p>Create an instance for a backup destination.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>Name of the target</p> required <code>target_config</code> <code>BackupTarget</code> <p>Target config</p> required <code>connection</code> <code>Connection</code> <p>Host connection</p> required <p>Returns:</p> Type Description <code>DestinationBackupTargetHost</code> <p>BackupHost instance</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>@classmethod\ndef from_destination_host(\n    cls,\n    target_name: str,\n    target_config: BackupTarget,\n    connection: Connection,\n) -&gt; \"DestinationBackupTargetHost\":\n    \"\"\"\n    Create an instance for a backup destination.\n\n    Args:\n        target_name: Name of the target\n        target_config: Target config\n        connection: Host connection\n\n    Returns:\n        BackupHost instance\n    \"\"\"\n    host = DestinationBackupTargetHost(\n        name=target_name,\n        target_config=target_config,\n        snapshot_dir=BackupHostPath(\n            connection.location / \"snapshots\" / target_name, connection=connection\n        ),\n        connection=connection,\n    )\n\n    if (\n        target_config.if_dst_dir_not_found == OnDestinationDirNotFound.FAIL\n        and not host.path().exists()\n    ):\n        raise exceptions.DestinationDirectoryNotFoundError(\n            \"Destination directory does not exist. B4 is configured to fail. Is the device mounted properly?\"\n        )\n\n    return host\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.from_source_host","title":"from_source_host  <code>classmethod</code>","text":"<pre><code>from_source_host(target_name, target_config, connection)\n</code></pre> <p>Create an instance for a backup source.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>Name of the target</p> required <code>target_config</code> <code>BackupTarget</code> <p>Target config</p> required <code>connection</code> <code>Connection</code> <p>Host connection</p> required <p>Returns:</p> Type Description <code>SourceBackupTargetHost</code> <p>BackupHost instance</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>@classmethod\ndef from_source_host(\n    cls,\n    target_name: str,\n    target_config: BackupTarget,\n    connection: Connection,\n) -&gt; \"SourceBackupTargetHost\":\n    \"\"\"\n    Create an instance for a backup source.\n\n    Args:\n        target_name: Name of the target\n        target_config: Target config\n        connection: Host connection\n\n    Returns:\n        BackupHost instance\n    \"\"\"\n    target_snapshot_dir = (\n        BackupTargetHost._mount_point(connection)\n        / target_config.src_snapshot_dir\n        / \"snapshots\"\n        / target_name\n    )\n\n    return SourceBackupTargetHost(\n        name=target_name,\n        target_config=target_config,\n        snapshot_dir=BackupHostPath(target_snapshot_dir, connection=connection),\n        connection=connection,\n    )\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.mount_point","title":"mount_point","text":"<pre><code>mount_point()\n</code></pre> <p>Returns:</p> Type Description <code>BackupHostPath</code> <p>the mount point of the target location.</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def mount_point(self) -&gt; BackupHostPath:\n    \"\"\"\n    Returns:\n        the mount point of the target location.\n    \"\"\"\n    return self._mount_point(self.connection)\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.path","title":"path","text":"<pre><code>path(path=None)\n</code></pre> <p>Create a BackupHostPath instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PurePath | str | None</code> <p>Pathlike object. If None, the connection location will be used</p> <code>None</code> <p>Returns:</p> Type Description <code>BackupHostPath</code> <p>BackupHostPath instance</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def path(self, path: PurePath | str | None = None) -&gt; BackupHostPath:\n    \"\"\"\n    Create a BackupHostPath instance.\n\n    Args:\n        path: Pathlike object. If None, the connection location will be used\n\n    Returns:\n        BackupHostPath instance\n    \"\"\"\n    if path is None:\n        path = self.connection.location\n\n    return BackupHostPath(path, connection=self.connection)\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.remove_empty_dirs","title":"remove_empty_dirs","text":"<pre><code>remove_empty_dirs(path, _subvolumes=None)\n</code></pre> <p>Recursively delete empty directories.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the top dir got deleted.</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def remove_empty_dirs(\n    self, path: BackupHostPath, _subvolumes: set[BackupHostPath] | None = None\n) -&gt; bool:\n    \"\"\"\n    Recursively delete empty directories.\n\n    Returns:\n        True if the top dir got deleted.\n    \"\"\"\n    if _subvolumes is None:\n        _subvolumes = set(self.subvolumes())\n\n    empty = True\n    for subpath in path.iterdir():\n        if (\n            subpath in _subvolumes\n            or not subpath.is_dir()\n            or not self.remove_empty_dirs(subpath, _subvolumes=_subvolumes)\n        ):\n            empty = False\n\n    if empty:\n        log.debug(\"Removing empty dir: %s\", path)\n        path.rmdir()\n\n    return empty\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.send_snapshot","title":"send_snapshot","text":"<pre><code>send_snapshot(\n    destination,\n    snapshot_name,\n    send_con=LocalConnection(PurePath()),\n    incremental=True,\n)\n</code></pre> <p>Send a snapshot to the destination host.</p> <p>Parameters:</p> Name Type Description Default <code>destination</code> <code>BackupTargetHost</code> <p>Destination host</p> required <code>snapshot_name</code> <code>str</code> <p>snapshot to transmit</p> required <code>send_con</code> <code>LocalConnection</code> <p>Optional connection from where to send from</p> <code>LocalConnection(PurePath())</code> <code>incremental</code> <code>bool</code> <p>Only send the difference from the nearest snapshot already sent</p> <code>True</code> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def send_snapshot(\n    self,\n    destination: \"BackupTargetHost\",\n    snapshot_name: str,\n    send_con: LocalConnection = LocalConnection(PurePath()),\n    incremental: bool = True,\n) -&gt; None:\n    \"\"\"\n    Send a snapshot to the destination host.\n\n    Args:\n        destination: Destination host\n        snapshot_name: snapshot to transmit\n        send_con: Optional connection from where to send from\n        incremental: Only send the difference from the nearest snapshot already sent\n    \"\"\"\n    src_snapshots = self.snapshots()\n    dst_snapshots = destination.snapshots()\n    self._remove_source_subvolumes(src_snapshots)\n\n    if snapshot_name in dst_snapshots:\n        log.info(\"Snapshot already present at %s\", destination.type)\n        return\n\n    if snapshot_name not in src_snapshots:\n        raise exceptions.SnapshotNotFoundError(f\"The snapshot {snapshot_name} does not exist.\")\n\n    snapshot = src_snapshots[snapshot_name]\n\n    parent_snapshot_name = None\n    if incremental:\n        parent_snapshot_name = self._get_nearest_matching_snapshot(\n            src_group_names=set(src_snapshots),\n            dst_group_names=set(dst_snapshots),\n            snapshot_name=snapshot_name,\n        )\n\n    snapshot_parent_mapping = None\n    if parent_snapshot_name:\n        log.info(\"Using incremental send based on snapshot: %s\", parent_snapshot_name)\n        parent_snapshot = src_snapshots[parent_snapshot_name]\n        snapshot_parent_mapping = self._map_parent_snapshots(snapshot, parent_snapshot)\n\n    (destination.snapshot_dir / snapshot_name).mkdir(parents=True)\n\n    with send_con:\n        for subvol in snapshot.subvolumes:\n            parent_param = \"\"\n            if (\n                parent_snapshot_name\n                and snapshot_parent_mapping is not None\n                and snapshot_parent_mapping[subvol] is True\n            ):\n                parent_param = (\n                    f\" -p {shlex.quote(str(self.snapshot_dir / parent_snapshot_name / subvol))}\"\n                )\n\n            send_cmd = (\n                f\"{self.connection.exec_prefix}btrfs send{parent_param}\"\n                f\" {shlex.quote(str(self.snapshot_dir / snapshot_name / subvol))}\"\n            )\n            receive_cmd = (\n                f\"{destination.connection.exec_prefix}btrfs receive\"\n                f\" {shlex.quote(str(destination.snapshot_dir / snapshot_name))}\"\n            )\n            log.info(\n                \"Sending snapshot: %s from %s to %s\",\n                str(snapshot_name / subvol),\n                self.type,\n                destination.type,\n            )\n            send_con.run_process([\"bash\", \"-c\", f\"{send_cmd} | {receive_cmd}\"])\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.snapshots","title":"snapshots","text":"<pre><code>snapshots()\n</code></pre> <p>Returns:</p> Type Description <code>dict[str, Snapshot]</code> <p>All snapshots for that host/target.</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def snapshots(self) -&gt; dict[str, Snapshot]:\n    \"\"\"\n    Returns:\n        All snapshots for that host/target.\n    \"\"\"\n    return {\n        k: Snapshot(\n            name=k,\n            subvolumes=v,\n            base_path=self.snapshot_dir,\n        )\n        for k, v in self._group_subvolumes(\n            self.subvolumes(),\n            self.snapshot_dir,\n        ).items()\n    }\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.source_subvolumes_from_snapshot","title":"source_subvolumes_from_snapshot","text":"<pre><code>source_subvolumes_from_snapshot(snapshot)\n</code></pre> <p>Retrieve subvolumes that are marked as source only and ignore from a snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot</code> <code>Snapshot</code> <p>Snapshot to retrieve the subvolumes from</p> required <p>Returns:</p> Type Description <code>None</code> <p>Generator of subvolumes</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def source_subvolumes_from_snapshot(\n    self, snapshot: Snapshot\n) -&gt; Generator[BackupHostPath, None, None]:\n    \"\"\"\n    Retrieve subvolumes that are marked as source only and ignore from a snapshot.\n\n    Args:\n        snapshot: Snapshot to retrieve the subvolumes from\n\n    Returns:\n        Generator of subvolumes\n    \"\"\"\n    return (\n        Snapshot.escape_path(x)\n        for x in self.filter_subvolumes_by_backup_strategy(\n            snapshot.subvolumes_unescaped,\n            {SubvolumeBackupStrategy.SOURCE_ONLY, SubvolumeBackupStrategy.IGNORE},\n        )\n    )\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.BackupTargetHost.subvolumes","title":"subvolumes","text":"<pre><code>subvolumes()\n</code></pre> <p>Returns:</p> Type Description <code>list[BackupHostPath]</code> <p>A list of btrfs subvolumes.</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def subvolumes(self) -&gt; list[BackupHostPath]:\n    \"\"\"\n    Returns:\n        A list of btrfs subvolumes.\n    \"\"\"\n    mount_point = self.mount_point()\n\n    result = self.connection.run_process([\"btrfs\", \"subvolume\", \"list\", str(mount_point)])\n    result = result.replace(\"top level\", \"top_level\")\n\n    # Format looking like this per line:\n    # ID 256 gen 621187 top_level 5 path my_data\n    return sorted(\n        [\n            mount_point / value\n            for line in result.split(\"\\n\")\n            # Iterate two items at a time\n            for key, value in zip(*[iter(line.split())] * 2)  # type: ignore\n            if key == \"path\"\n        ]\n        + [mount_point]\n    )\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.DestinationBackupTargetHost","title":"DestinationBackupTargetHost  <code>dataclass</code>","text":"<pre><code>DestinationBackupTargetHost(\n    name, target_config, snapshot_dir, connection\n)\n</code></pre> <p>               Bases: <code>BackupTargetHost</code></p> <p>Describes a destination host containing backups. An extention of the generic BackupHost.</p>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.DestinationBackupTargetHost.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>if it's a source or destination host.</p>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.SourceBackupTargetHost","title":"SourceBackupTargetHost  <code>dataclass</code>","text":"<pre><code>SourceBackupTargetHost(\n    name, target_config, snapshot_dir, connection\n)\n</code></pre> <p>               Bases: <code>BackupTargetHost</code></p> <p>Describes a source host containing backups. An extention of the generic BackupHost.</p>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.SourceBackupTargetHost.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>if it's a source or destination host.</p>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.SourceBackupTargetHost.create_snapshot","title":"create_snapshot","text":"<pre><code>create_snapshot(snapshot_name)\n</code></pre> <p>Create a new snapshot for this target with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot_name</code> <code>str</code> <p>Name of the snapshot.</p> required <p>Returns:</p> Type Description <code>Snapshot</code> <p>Instance of the newly created snapshot.</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def create_snapshot(self, snapshot_name: str) -&gt; Snapshot:\n    \"\"\"\n    Create a new snapshot for this target with the given name.\n\n    Args:\n        snapshot_name: Name of the snapshot.\n\n    Returns:\n        Instance of the newly created snapshot.\n    \"\"\"\n    log.debug(\"Identify target subvolumes to backup\")\n\n    src_subvolumes = self.subvolumes()\n    src_target_subvolumes = [\n        self.path(\"/\") / x.relative_to(self.connection.location)\n        for x in src_subvolumes\n        if x.is_relative_to(self.connection.location)\n    ]\n\n    for subvolume in list(\n        self.filter_subvolumes_by_backup_strategy(\n            src_target_subvolumes, {SubvolumeBackupStrategy.IGNORE}\n        )\n    ):\n        src_target_subvolumes.remove(subvolume)\n\n    if not src_target_subvolumes:\n        raise exceptions.BtrfsSubvolumeNotFoundError(\n            f\"The target {self.name} does not contain any btrfs subvolumes\"\n        )\n\n    snapshot = Snapshot.from_new(\n        name=snapshot_name,\n        subvolumes=src_target_subvolumes,\n        base_path=self.snapshot_dir,\n    )\n\n    original_src_target_subvolumes = [\n        self.connection.location / x for x in snapshot.subvolumes_unescaped\n    ]\n    new_src_target_snapshots = [\n        self.snapshot_dir / snapshot.name / x for x in snapshot.subvolumes\n    ]\n\n    log.debug(\"Create snapshots\")\n    (snapshot.base_path / snapshot.name).mkdir(parents=True)\n\n    for source_path, snapshot_path in zip(\n        original_src_target_subvolumes, new_src_target_snapshots\n    ):\n        self.connection.run_process(\n            [\"btrfs\", \"subvolume\", \"snapshot\", \"-r\", str(source_path), str(snapshot_path)]\n        )\n\n    return snapshot\n</code></pre>"},{"location":"reference/code/main/backup_target_host.html#b4_backup.main.backup_target_host.host_generator","title":"host_generator","text":"<pre><code>host_generator(\n    target_choice,\n    backup_targets,\n    *,\n    use_source=True,\n    use_destination=True,\n)\n</code></pre> <p>Creates a generator containing connected TargetHosts for source and destination.</p> <p>Parameters:</p> Name Type Description Default <code>target_choice</code> <code>ChoiceSelector</code> <p>A ChoiceSelector list of targets to be used</p> required <code>backup_targets</code> <code>dict[str, BackupTarget]</code> <p>A dict containing all targets available</p> required <code>use_source</code> <code>bool</code> <p>If false, the source host will be omitted</p> <code>True</code> <code>use_destination</code> <code>bool</code> <p>If false, the destination host will be omitted</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>A tuple containing source and destination TargetHosts</p> Source code in <code>b4_backup/main/backup_target_host.py</code> <pre><code>def host_generator(\n    target_choice: ChoiceSelector,\n    backup_targets: dict[str, BackupTarget],\n    *,\n    use_source: bool = True,\n    use_destination: bool = True,\n) -&gt; Generator[\n    tuple[SourceBackupTargetHost | None, DestinationBackupTargetHost | None], None, None\n]:\n    \"\"\"\n    Creates a generator containing connected TargetHosts for source and destination.\n\n    Args:\n        target_choice: A ChoiceSelector list of targets to be used\n        backup_targets: A dict containing all targets available\n        use_source: If false, the source host will be omitted\n        use_destination: If false, the destination host will be omitted\n\n    Returns:\n        A tuple containing source and destination TargetHosts\n    \"\"\"\n    target_names = target_choice.resolve_target(backup_targets)\n    target_connections = sorted(\n        (\n            (\n                target_name,\n                Connection.from_url(backup_targets[target_name].source if use_source else None),\n                Connection.from_url(\n                    backup_targets[target_name].destination if use_destination else None\n                ),\n            )\n            for target_name in target_names\n        ),\n        key=_connection_sort_key,\n    )\n    _mark_keep_open(target_connections)\n\n    for target_name, source, destination in target_connections:\n        log.info(\"Backup target: %s\", target_name)\n\n        with source as src_con, destination as dst_con:\n            src_host = None\n            if src_con:\n                src_host = BackupTargetHost.from_source_host(\n                    target_name=target_name,\n                    target_config=backup_targets[target_name],\n                    connection=src_con,\n                )\n\n            dst_host = None\n            if dst_con:\n                dst_host = BackupTargetHost.from_destination_host(\n                    target_name=target_name,\n                    target_config=backup_targets[target_name],\n                    connection=dst_con,\n                )\n\n            yield src_host, dst_host\n</code></pre>"},{"location":"reference/code/main/connection.html","title":"Connection","text":""},{"location":"reference/code/main/connection.html#b4_backup.main.connection.Connection","title":"Connection","text":"<pre><code>Connection(location)\n</code></pre> <p>An abstract connection wrapper to execute commands on machines.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>PurePath</code> <p>Target directory or file.</p> required Source code in <code>b4_backup/main/connection.py</code> <pre><code>def __init__(self, location: PurePath) -&gt; None:\n    \"\"\"\n    Args:\n        location: Target directory or file.\n    \"\"\"\n    self.location = location\n    self.keep_open = False\n\n    self.connected: bool = False\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.Connection.exec_prefix","title":"exec_prefix  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>exec_prefix\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>Prefix to run commands on the target using local commands.</p>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.Connection.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Entrypoint in a \"with\" statement.</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def __enter__(self) -&gt; Connection:\n    \"\"\"Entrypoint in a \"with\" statement.\"\"\"\n    return self.open()\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.Connection.__exit__","title":"__exit__","text":"<pre><code>__exit__(*args, **kwargs)\n</code></pre> <p>Endpoint in a \"with\" statement.</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def __exit__(self, *args, **kwargs) -&gt; None:\n    \"\"\"Endpoint in a \"with\" statement.\"\"\"\n    if not self.keep_open:\n        self.close()\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.Connection.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close()\n</code></pre> <p>Close the connection.</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>@abstractmethod\ndef close(self) -&gt; None:\n    \"\"\"Close the connection.\"\"\"\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.Connection.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(url)\n</code></pre> <p>Parse the URL and return a fitting connection instance.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str | None</code> <p>URL string to parse</p> required <p>Returns:</p> Type Description <code>Connection | nullcontext</code> <p>Connection instance</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str | None) -&gt; Connection | contextlib.nullcontext:\n    \"\"\"\n    Parse the URL and return a fitting connection instance.\n\n    Args:\n        url: URL string to parse\n\n    Returns:\n        Connection instance\n    \"\"\"\n    if url is None:\n        return contextlib.nullcontext()\n\n    parsed_url = URL.from_url(url)\n\n    if parsed_url.protocol is None:\n        return LocalConnection(parsed_url.location)\n\n    if parsed_url.protocol == \"ssh\":\n        assert parsed_url.host is not None\n\n        return SSHConnection(\n            host=parsed_url.host,\n            port=parsed_url.port,\n            user=parsed_url.user,\n            password=parsed_url.password,\n            location=parsed_url.location,\n        )\n\n    raise exceptions.UnknownProtocolError\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.Connection.open","title":"open  <code>abstractmethod</code>","text":"<pre><code>open()\n</code></pre> <p>Open the connection to the target host.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Itself</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>@abstractmethod\ndef open(self) -&gt; Connection:\n    \"\"\"\n    Open the connection to the target host.\n\n    Returns:\n        Itself\n    \"\"\"\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.Connection.run_process","title":"run_process  <code>abstractmethod</code>","text":"<pre><code>run_process(command)\n</code></pre> <p>Run a process without interaction and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>list[str]</code> <p>List of parameters</p> required <p>Returns:     stdout of process.</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>@abstractmethod\ndef run_process(self, command: list[str]) -&gt; str:\n    \"\"\"\n    Run a process without interaction and return the result.\n\n    Args:\n        command: List of parameters\n    Returns:\n        stdout of process.\n    \"\"\"\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.LocalConnection","title":"LocalConnection","text":"<pre><code>LocalConnection(location)\n</code></pre> <p>               Bases: <code>Connection</code></p> <p>A connection wrapper to execute commands on the local machine.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>PurePath</code> <p>Target directory or file.</p> required Source code in <code>b4_backup/main/connection.py</code> <pre><code>def __init__(self, location: PurePath) -&gt; None:\n    \"\"\"\n    Args:\n        location: Target directory or file.\n    \"\"\"\n    super().__init__(location)\n\n    self.location: PurePath = location\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.LocalConnection.exec_prefix","title":"exec_prefix  <code>property</code>","text":"<pre><code>exec_prefix\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>Prefix to run commands on the target using local commands.</p>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.LocalConnection.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the connection.</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the connection.\"\"\"\n    assert self.connected, \"Connection already closed\"\n\n    self.connected = False\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.LocalConnection.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Open the connection to the target host.</p> <p>Returns:</p> Type Description <code>Connection</code> <p>Itself</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def open(self) -&gt; Connection:\n    \"\"\"\n    Open the connection to the target host.\n\n    Returns:\n        Itself\n    \"\"\"\n    log.info(\"Opening local connection to %s\", self.location)\n    self.connected = True\n\n    return self\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.LocalConnection.run_process","title":"run_process","text":"<pre><code>run_process(command)\n</code></pre> <p>Run a process without interaction and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>list[str]</code> <p>List of parameters</p> required <p>Returns:     stdout of process.</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def run_process(self, command: list[str]) -&gt; str:\n    \"\"\"\n    Run a process without interaction and return the result.\n\n    Args:\n        command: List of parameters\n    Returns:\n        stdout of process.\n    \"\"\"\n    log.debug(\"Start local process:\\n%s\", command)\n    with subprocess.Popen(  # noqa: S603\n        command,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        stdin=subprocess.PIPE,\n    ) as process:\n        stdout, stderr = process.communicate()\n        stdout = stdout.decode()\n        stderr = stderr.decode()\n\n    if process.returncode:\n        raise exceptions.FailedProcessError(command, stdout, stderr)\n\n    return stdout\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.SSHConnection","title":"SSHConnection","text":"<pre><code>SSHConnection(\n    host, location, port=22, user=\"root\", password=None\n)\n</code></pre> <p>               Bases: <code>Connection</code></p> <p>A connection wrapper to execute commands on remote machines via SSH.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname</p> required <code>location</code> <code>PurePath</code> <p>Target directory or file</p> required <code>port</code> <code>int</code> <p>Port</p> <code>22</code> <code>user</code> <code>str</code> <p>Username</p> <code>'root'</code> <code>password</code> <code>str | None</code> <p>Optional password. SSH key recommended.</p> <code>None</code> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    location: PurePath,\n    port: int = 22,\n    user: str = \"root\",\n    password: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Args:\n        host: Hostname\n        location: Target directory or file\n        port: Port\n        user: Username\n        password: Optional password. SSH key recommended.\n    \"\"\"\n    super().__init__(location)\n\n    self.host = host\n    self.port = port\n    self.user = user\n    self.password = password\n    self._ssh_client: paramiko.SSHClient | None\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.SSHConnection.exec_prefix","title":"exec_prefix  <code>property</code>","text":"<pre><code>exec_prefix\n</code></pre> <p>Returns:</p> Type Description <code>str</code> <p>Prefix to run commands on the target using local commands.</p>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.SSHConnection.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the connection.</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close the connection.\"\"\"\n    assert self.connected, \"Connection already closed\"\n    assert self._ssh_client\n\n    log.info(\"Closing ssh connection to %s %s\", self.host, self.location)\n    self._ssh_client.close()\n    del SSHConnection.ssh_client_pool[(self.host, self.port, self.user)]\n    self.connected = False\n    self._ssh_client = None\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.SSHConnection.open","title":"open","text":"<pre><code>open()\n</code></pre> <p>Open the connection to the target host.</p> <p>Returns:</p> Type Description <code>SSHConnection</code> <p>Itself</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def open(self) -&gt; SSHConnection:\n    \"\"\"\n    Open the connection to the target host.\n\n    Returns:\n        Itself\n    \"\"\"\n    ssh_client = SSHConnection.ssh_client_pool.get((self.host, self.port, self.user), None)\n    if not ssh_client:\n        ssh_client = paramiko.SSHClient()\n        ssh_client.load_system_host_keys()\n        ssh_client.set_missing_host_key_policy(paramiko.RejectPolicy())\n\n        log.info(\"Opening ssh connection to %s@%s:%s\", self.user, self.host, self.port)\n        ssh_client.connect(\n            self.host,\n            username=self.user,\n            password=self.password,\n            port=self.port,\n        )\n        SSHConnection.ssh_client_pool[(self.host, self.port, self.user)] = ssh_client\n\n    self.connected = True\n    self._ssh_client = ssh_client\n\n    return self\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.SSHConnection.run_process","title":"run_process","text":"<pre><code>run_process(command)\n</code></pre> <p>Run a process without interaction and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>list[str]</code> <p>List of parameters</p> required <p>Returns:     stdout of process.</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>def run_process(self, command: list[str]) -&gt; str:\n    \"\"\"\n    Run a process without interaction and return the result.\n\n    Args:\n        command: List of parameters\n    Returns:\n        stdout of process.\n    \"\"\"\n    assert self._ssh_client, \"Not connected\"\n\n    log.debug(\"Start SSH process:\\n%s\", command)\n\n    _stdin, stdout, stderr = self._ssh_client.exec_command(shlex.join(command))\n    stdout_str = stdout.read().decode()\n    stderr_str = stderr.read().decode()\n\n    if stdout.channel.recv_exit_status():\n        raise exceptions.FailedProcessError(command, stdout_str, stderr_str)\n\n    return stdout_str\n</code></pre>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.URL","title":"URL  <code>dataclass</code>","text":"<pre><code>URL(\n    protocol=None,\n    user=\"root\",\n    password=None,\n    host=None,\n    port=0,\n    location=PurePath(\"/\"),\n)\n</code></pre> <p>Contains an URL.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>str | None</code> <p>protocol used. eg. ssh</p> <code>None</code> <code>user</code> <code>str</code> <p>Username</p> <code>'root'</code> <code>password</code> <code>str | None</code> <p>Password</p> <code>None</code> <code>host</code> <code>str | None</code> <p>Hostname</p> <code>None</code> <code>port</code> <code>int</code> <p>Port</p> <code>0</code> <code>location</code> <code>PurePath</code> <p>Protocol specific location</p> <code>PurePath('/')</code>"},{"location":"reference/code/main/connection.html#b4_backup.main.connection.URL.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(source)\n</code></pre> <p>Create an instance by providing an URL string.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>URL string</p> required <p>Returns:</p> Type Description <code>URL</code> <p>ParsedURL instance</p> Source code in <code>b4_backup/main/connection.py</code> <pre><code>@classmethod\ndef from_url(cls, source: str) -&gt; URL:\n    \"\"\"\n    Create an instance by providing an URL string.\n\n    Args:\n        source: URL string\n\n    Returns:\n        ParsedURL instance\n    \"\"\"\n    result = cls._url_pattern.match(source)\n\n    if not result:\n        result = cls._local_dir_pattern.match(source)\n\n    if not result:\n        raise exceptions.InvalidConnectionUrlError(\n            f\"The connection url {source} got an invalid format.\"\n        )\n\n    result_dict = asdict(URL())\n    result_dict.update(result.groupdict())\n\n    if result_dict[\"protocol\"] is not None:\n        result_dict[\"protocol\"] = result_dict[\"protocol\"].lower()\n\n    return URL(\n        protocol=result_dict[\"protocol\"],\n        user=result_dict[\"user\"] or URL.user,\n        password=result_dict[\"password\"],\n        host=result_dict[\"host\"],\n        port=int(result_dict[\"port\"] or cls._protocol_mapping.get(result_dict[\"protocol\"], 0)),\n        location=PurePath(result_dict[\"location\"] or \"/\"),\n    )\n</code></pre>"},{"location":"reference/code/main/dataclass.html","title":"Dataclass","text":""},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.BackupHostPath","title":"BackupHostPath","text":"<pre><code>BackupHostPath(*segments, connection)\n</code></pre> <p>               Bases: <code>PurePosixPath</code></p> <p>Represents a path for a Connection.</p> <p>Parameters:</p> Name Type Description Default <code>segments</code> <code>str | PathLike[str]</code> <p>segments of the path</p> <code>()</code> <code>connection</code> <code>Connection</code> <p>The connection used for this path.</p> required Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def __init__(self, *segments: str | PathLike[str], connection: \"Connection\"):\n    \"\"\"\n    Args:\n        segments: segments of the path\n        connection: The connection used for this path.\n    \"\"\"\n    super().__init__(*segments)\n    self.connection = connection\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.BackupHostPath.exists","title":"exists","text":"<pre><code>exists()\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if the location exists.</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"\n    Returns:\n        True if the location exists.\n    \"\"\"\n    try:\n        result = self.connection.run_process([\"ls\", \"-d\", str(self)])\n    except exceptions.FailedProcessError as e:\n        if \"No such file or directory\" in e.stderr:\n            return False\n\n        raise\n\n    return result.strip() != \"\"\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.BackupHostPath.is_dir","title":"is_dir","text":"<pre><code>is_dir()\n</code></pre> <p>Checks if a path is a directory.</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def is_dir(self) -&gt; bool:\n    \"\"\"Checks if a path is a directory.\"\"\"\n    result = self.connection.run_process([\"ls\", \"-dl\", str(self)])\n    return result.strip()[0] == \"d\"\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.BackupHostPath.iterdir","title":"iterdir","text":"<pre><code>iterdir()\n</code></pre> <p>Returns:</p> Type Description <code>list[BackupHostPath]</code> <p>A list of Paths containing all items in the current directory.</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def iterdir(self) -&gt; list[\"BackupHostPath\"]:\n    \"\"\"\n    Returns:\n        A list of Paths containing all items in the current directory.\n    \"\"\"\n    result = sorted(self.connection.run_process([\"ls\", str(self)]).strip().split(\"\\n\"))\n\n    if result == [\"\"]:\n        return []\n\n    return [self / x for x in result]\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.BackupHostPath.mkdir","title":"mkdir","text":"<pre><code>mkdir(parents=False)\n</code></pre> <p>Creates a directory.</p> <p>Parameters:</p> Name Type Description Default <code>parents</code> <code>bool</code> <p>Also creates parent directories and doesn't fail if path exist.</p> <code>False</code> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def mkdir(self, parents: bool = False) -&gt; None:\n    \"\"\"\n    Creates a directory.\n\n    Args:\n        parents: Also creates parent directories and doesn't fail if path exist.\n    \"\"\"\n    self.connection.run_process([\"mkdir\", str(self)] + [\"-p\"] * parents)\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.BackupHostPath.rename","title":"rename","text":"<pre><code>rename(target)\n</code></pre> <p>Renames/Moves the path to the target location.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>PurePath</code> <p>The target location to move the object to.</p> required Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def rename(self, target: PurePath) -&gt; None:\n    \"\"\"\n    Renames/Moves the path to the target location.\n\n    Args:\n        target: The target location to move the object to.\n    \"\"\"\n    self.connection.run_process([\"mv\", str(self), str(target)])\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.BackupHostPath.rmdir","title":"rmdir","text":"<pre><code>rmdir()\n</code></pre> <p>Removes the given empty directory.</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def rmdir(self) -&gt; None:\n    \"\"\"Removes the given empty directory.\"\"\"\n    try:\n        self.connection.run_process([\"rmdir\", str(self)])\n    except exceptions.FailedProcessError as e:\n        if \"No such file or directory\" not in e.stderr:\n            raise\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.ChoiceSelector","title":"ChoiceSelector  <code>dataclass</code>","text":"<pre><code>ChoiceSelector(data=list())\n</code></pre> <p>Describes a set of data, with dynamic choices.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>list[str]</code> <p>Contains the actual data</p>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.ChoiceSelector.resolve_retention_name","title":"resolve_retention_name","text":"<pre><code>resolve_retention_name(snapshot_names)\n</code></pre> <p>Resolves a retention_name selector and returns a list based on the selection.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of resolved items</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def resolve_retention_name(self, snapshot_names: Iterable[str]) -&gt; list[str]:\n    \"\"\"\n    Resolves a retention_name selector and returns a list based on the selection.\n\n    Returns:\n        List of resolved items\n    \"\"\"\n    if self.data == [\"ALL\"]:\n        return list({x.split(\"_\", maxsplit=1)[1] for x in snapshot_names})\n\n    return self.data\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.ChoiceSelector.resolve_target","title":"resolve_target","text":"<pre><code>resolve_target(targets)\n</code></pre> <p>Resolves a target selector and returns a list based on the selection.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of resolved items</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>def resolve_target(self, targets: Iterable[str]) -&gt; list[str]:\n    \"\"\"\n    Resolves a target selector and returns a list based on the selection.\n\n    Returns:\n        List of resolved items\n    \"\"\"\n    expanded_data: set[str] = set()\n    for item in self.data:\n        if item in targets:\n            expanded_data.add(item)\n            continue\n\n        for target_name in targets:\n            if PurePath(target_name).is_relative_to(item):\n                expanded_data.add(target_name)\n\n    return list(expanded_data - {\"_default\"})\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.RetentionGroup","title":"RetentionGroup  <code>dataclass</code>","text":"<pre><code>RetentionGroup(\n    name,\n    target_retention,\n    is_source=True,\n    obsolete_snapshots=set(),\n)\n</code></pre> <p>Contains the retention ruleset for a target.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the retention ruleset</p> <code>target_retention</code> <code>dict[str, str]</code> <p>The retention ruleset for the target itself</p> <code>is_source</code> <code>bool</code> <p>True if this is a source retention ruleset</p> <code>obsolete_snapshots</code> <code>set[str]</code> <p>All snapshots in this set will be condidered obsolete</p>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.RetentionGroup.from_target","title":"from_target  <code>classmethod</code>","text":"<pre><code>from_target(\n    retention_name,\n    target,\n    is_source=True,\n    obsolete_snapshots=None,\n)\n</code></pre> <p>Create an instance from a target and ruleset name.</p> <p>Parameters:</p> Name Type Description Default <code>retention_name</code> <code>str</code> <p>Name of the retention ruleset to select from the target</p> required <code>target</code> <code>BackupTarget</code> <p>Target to get the ruleset from</p> required <code>is_source</code> <code>bool</code> <p>Select source ruleset or destination ruleset</p> <code>True</code> <code>obsolete_snapshots</code> <code>set[str] | None</code> <p>All snapshots in this set will be condidered obsolete</p> <code>None</code> <p>Returns:</p> Type Description <code>RetentionGroup</code> <p>RetentionGroup instance</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>@classmethod\ndef from_target(\n    cls,\n    retention_name: str,\n    target: BackupTarget,\n    is_source: bool = True,\n    obsolete_snapshots: set[str] | None = None,\n) -&gt; \"RetentionGroup\":\n    \"\"\"\n    Create an instance from a target and ruleset name.\n\n    Args:\n        retention_name: Name of the retention ruleset to select from the target\n        target: Target to get the ruleset from\n        is_source: Select source ruleset or destination ruleset\n        obsolete_snapshots: All snapshots in this set will be condidered obsolete\n\n    Returns:\n        RetentionGroup instance\n    \"\"\"\n    target_retentions = target.src_retention if is_source else target.dst_retention\n    target_retention = target_retentions.get(retention_name) or target_retentions[DEFAULT]\n\n    return RetentionGroup(\n        name=retention_name,\n        target_retention=target_retention,\n        is_source=is_source,\n        obsolete_snapshots=obsolete_snapshots or set(),\n    )\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.Snapshot","title":"Snapshot  <code>dataclass</code>","text":"<pre><code>Snapshot(\n    name, subvolumes, base_path, _subvolume_delimiter=\"!\"\n)\n</code></pre> <p>Describes a b4_snapshot.</p>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.Snapshot.subvolumes_unescaped","title":"subvolumes_unescaped  <code>property</code>","text":"<pre><code>subvolumes_unescaped\n</code></pre> <p>Returns:</p> Type Description <code>None</code> <p>List all subvolumes without delimiter translation as relative paths.</p>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.Snapshot.escape_path","title":"escape_path  <code>classmethod</code>","text":"<pre><code>escape_path(path)\n</code></pre> <p>Returns:</p> Type Description <code>BackupHostPath</code> <p>Escaped variant of subvolume path.</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>@classmethod\ndef escape_path(cls, path: BackupHostPath) -&gt; BackupHostPath:\n    \"\"\"\n    Returns:\n        Escaped variant of subvolume path.\n    \"\"\"\n    return BackupHostPath(\n        str(path).replace(\"/\", cls._subvolume_delimiter),\n        connection=path.connection,\n    )\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.Snapshot.from_new","title":"from_new  <code>classmethod</code>","text":"<pre><code>from_new(name, subvolumes, base_path)\n</code></pre> <p>Create instance from the backup target location.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the snapshot</p> required <code>subvolumes</code> <code>list[BackupHostPath]</code> <p>List of subvolumes without delimiter translation</p> required <code>base_path</code> <code>BackupHostPath</code> <p>Location of this snapshot</p> required Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>@classmethod\ndef from_new(\n    cls, name: str, subvolumes: list[BackupHostPath], base_path: BackupHostPath\n) -&gt; \"Snapshot\":\n    \"\"\"\n    Create instance from the backup target location.\n\n    Args:\n        name: Name of the snapshot\n        subvolumes: List of subvolumes without delimiter translation\n        base_path: Location of this snapshot\n    \"\"\"\n    return Snapshot(\n        name=name,\n        subvolumes=[cls.escape_path(x) for x in subvolumes],\n        base_path=base_path,\n    )\n</code></pre>"},{"location":"reference/code/main/dataclass.html#b4_backup.main.dataclass.Snapshot.unescape_path","title":"unescape_path  <code>classmethod</code>","text":"<pre><code>unescape_path(path)\n</code></pre> <p>Returns:</p> Type Description <code>BackupHostPath</code> <p>Recreates a path from an escaped variant of subvolume path.</p> Source code in <code>b4_backup/main/dataclass.py</code> <pre><code>@classmethod\ndef unescape_path(cls, path: BackupHostPath) -&gt; BackupHostPath:\n    \"\"\"\n    Returns:\n        Recreates a path from an escaped variant of subvolume path.\n    \"\"\"\n    return BackupHostPath(\n        str(path).replace(cls._subvolume_delimiter, \"/\"),\n        connection=path.connection,\n    )\n</code></pre>"}]}